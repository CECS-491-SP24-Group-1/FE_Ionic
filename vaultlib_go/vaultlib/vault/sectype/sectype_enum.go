// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package sectype

import (
	"fmt"
	"strings"
)

const (
	// No encrypted (not recommended).
	SecTypeNONE SecType = iota
	// Encrypted via a passphrase (most simple).
	SecTypePASSPHRASE
	// Encrypted via a scannable QR code.
	SecTypeQR
	// Encrypted via biometrics (fingerprint or face ID).
	SecTypeBIOMETRICS
	// Encrypted via a hardware security key.
	SecTypeSECKEY
)

var ErrInvalidSecType = fmt.Errorf("not a valid SecType, try [%s]", strings.Join(_SecTypeNames, ", "))

const _SecTypeName = "NONEPASSPHRASEQRBIOMETRICSSEC_KEY"

var _SecTypeNames = []string{
	_SecTypeName[0:4],
	_SecTypeName[4:14],
	_SecTypeName[14:16],
	_SecTypeName[16:26],
	_SecTypeName[26:33],
}

// SecTypeNames returns a list of possible string values of SecType.
func SecTypeNames() []string {
	tmp := make([]string, len(_SecTypeNames))
	copy(tmp, _SecTypeNames)
	return tmp
}

// SecTypeValues returns a list of the values for SecType
func SecTypeValues() []SecType {
	return []SecType{
		SecTypeNONE,
		SecTypePASSPHRASE,
		SecTypeQR,
		SecTypeBIOMETRICS,
		SecTypeSECKEY,
	}
}

var _SecTypeMap = map[SecType]string{
	SecTypeNONE:       _SecTypeName[0:4],
	SecTypePASSPHRASE: _SecTypeName[4:14],
	SecTypeQR:         _SecTypeName[14:16],
	SecTypeBIOMETRICS: _SecTypeName[16:26],
	SecTypeSECKEY:     _SecTypeName[26:33],
}

// String implements the Stringer interface.
func (x SecType) String() string {
	if str, ok := _SecTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("SecType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SecType) IsValid() bool {
	_, ok := _SecTypeMap[x]
	return ok
}

var _SecTypeValue = map[string]SecType{
	_SecTypeName[0:4]:   SecTypeNONE,
	_SecTypeName[4:14]:  SecTypePASSPHRASE,
	_SecTypeName[14:16]: SecTypeQR,
	_SecTypeName[16:26]: SecTypeBIOMETRICS,
	_SecTypeName[26:33]: SecTypeSECKEY,
}

// ParseSecType attempts to convert a string to a SecType.
func ParseSecType(name string) (SecType, error) {
	if x, ok := _SecTypeValue[name]; ok {
		return x, nil
	}
	return SecType(0), fmt.Errorf("%s is %w", name, ErrInvalidSecType)
}

// MustParseSecType converts a string to a SecType, and panics if is not valid.
func MustParseSecType(name string) SecType {
	val, err := ParseSecType(name)
	if err != nil {
		panic(err)
	}
	return val
}

// MarshalText implements the text marshaller method.
func (x SecType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SecType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseSecType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
